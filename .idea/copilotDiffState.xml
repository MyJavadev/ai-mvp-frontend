<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/cliente/data/remote/TTSApiService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/cliente/data/remote/TTSApiService.kt" />
              <option name="originalContent" value="package com.example.cliente.data.remote&#10;&#10;import com.example.cliente.data.model.ApiResponse&#10;import kotlinx.serialization.Serializable&#10;import retrofit2.http.*&#10;&#10;/**&#10; * API Service para Text-to-Speech según documentación del backend.&#10; *&#10; * Endpoints disponibles:&#10; * - POST /text-to-speech - Crea trabajo TTS (async)&#10; * - GET /text-to-speech/:jobId - Consulta estado de un trabajo&#10; * - GET /text-to-speech - Lista trabajos recientes (filtrable)&#10; */&#10;interface TTSApiService {&#10;&#10;    /**&#10;     * Crea un trabajo de texto a voz.&#10;     *&#10;     * POST /text-to-speech&#10;     * Body: { &quot;text&quot;: &quot;...&quot;, &quot;userId&quot;: 1, &quot;moduleId&quot;: 23 }&#10;     * Response: 202 { &quot;jobId&quot;: &quot;uuid&quot; }&#10;     */&#10;    @POST(&quot;text-to-speech&quot;)&#10;    suspend fun createTTSJob(&#10;        @Body request: CreateTTSRequest&#10;    ): TTSJobResponse&#10;&#10;    /**&#10;     * Consulta el estado de un trabajo TTS.&#10;     *&#10;     * GET /text-to-speech/:jobId&#10;     * Response: { &quot;status&quot;: &quot;pending|processing|completed|failed&quot;, &quot;audioUrl&quot;: &quot;...&quot;, ... }&#10;     */&#10;    @GET(&quot;text-to-speech/{jobId}&quot;)&#10;    suspend fun getTTSJob(&#10;        @Path(&quot;jobId&quot;) jobId: String&#10;    ): TTSJobStatusResponse&#10;&#10;    /**&#10;     * Lista los trabajos TTS recientes.&#10;     *&#10;     * GET /text-to-speech?userId=X&amp;moduleId=Y&amp;status=completed&#10;     * Response: [{ trabajos ordenados por created_at desc, max 50 }]&#10;     */&#10;    @GET(&quot;text-to-speech&quot;)&#10;    suspend fun getTTSJobs(&#10;        @Query(&quot;userId&quot;) userId: Int? = null,&#10;        @Query(&quot;moduleId&quot;) moduleId: Int? = null,&#10;        @Query(&quot;status&quot;) status: String? = null&#10;    ): List&lt;TTSJobStatusResponse&gt;&#10;}&#10;&#10;/**&#10; * Request para crear un trabajo TTS.&#10; */&#10;@Serializable&#10;data class CreateTTSRequest(&#10;    val text: String,&#10;    val userId: Int,&#10;    val moduleId: Int? = null&#10;)&#10;&#10;/**&#10; * Response al crear un trabajo TTS.&#10; */&#10;@Serializable&#10;data class TTSJobResponse(&#10;    val jobId: String&#10;)&#10;&#10;/**&#10; * Estado de un trabajo TTS.&#10; */&#10;@Serializable&#10;data class TTSJobStatusResponse(&#10;    val id: String,&#10;    val user_id: Int,&#10;    val module_id: Int? = null,&#10;    val status: String, // &quot;pending&quot;, &quot;processing&quot;, &quot;completed&quot;, &quot;failed&quot;&#10;    val audioUrl: String? = null,&#10;    val error: String? = null,&#10;    val created_at: String = &quot;&quot;,&#10;    val updated_at: String? = null&#10;)&#10;&#10;" />
              <option name="updatedContent" value="package com.example.cliente.data.remote&#10;&#10;import kotlinx.serialization.Serializable&#10;import retrofit2.http.*&#10;&#10;/**&#10; * API Service para Text-to-Speech según documentación del backend.&#10; *&#10; * Endpoints disponibles:&#10; * - POST /text-to-speech - Crea trabajo TTS (async)&#10; * - GET /text-to-speech/:jobId - Consulta estado de un trabajo&#10; * - GET /text-to-speech - Lista trabajos recientes (filtrable)&#10; */&#10;interface TTSApiService {&#10;&#10;    /**&#10;     * Crea un trabajo de texto a voz.&#10;     *&#10;     * POST /text-to-speech&#10;     * Body: { &quot;text&quot;: &quot;...&quot;, &quot;userId&quot;: 1, &quot;moduleId&quot;: 23 }&#10;     * Response: 202 { &quot;jobId&quot;: &quot;uuid&quot; }&#10;     */&#10;    @POST(&quot;text-to-speech&quot;)&#10;    suspend fun createTTSJob(&#10;        @Body request: CreateTTSRequest&#10;    ): TTSJobResponse&#10;&#10;    /**&#10;     * Consulta el estado de un trabajo TTS.&#10;     *&#10;     * GET /text-to-speech/:jobId&#10;     * Response: { &quot;status&quot;: &quot;pending|processing|completed|failed&quot;, &quot;audioUrl&quot;: &quot;...&quot;, ... }&#10;     */&#10;    @GET(&quot;text-to-speech/{jobId}&quot;)&#10;    suspend fun getTTSJob(&#10;        @Path(&quot;jobId&quot;) jobId: String&#10;    ): TTSJobStatusResponse&#10;&#10;    /**&#10;     * Lista los trabajos TTS recientes.&#10;     *&#10;     * GET /text-to-speech?userId=X&amp;moduleId=Y&amp;status=completed&#10;     * Response: [{ trabajos ordenados por created_at desc, max 50 }]&#10;     */&#10;    @GET(&quot;text-to-speech&quot;)&#10;    suspend fun getTTSJobs(&#10;        @Query(&quot;userId&quot;) userId: Int? = null,&#10;        @Query(&quot;moduleId&quot;) moduleId: Int? = null,&#10;        @Query(&quot;status&quot;) status: String? = null&#10;    ): List&lt;TTSJobStatusResponse&gt;&#10;}&#10;&#10;/**&#10; * Request para crear un trabajo TTS.&#10; */&#10;@Serializable&#10;data class CreateTTSRequest(&#10;    val text: String,&#10;    val userId: Int,&#10;    val moduleId: Int? = null&#10;)&#10;&#10;/**&#10; * Response al crear un trabajo TTS.&#10; */&#10;@Serializable&#10;data class TTSJobResponse(&#10;    val jobId: String&#10;)&#10;&#10;/**&#10; * Estado de un trabajo TTS.&#10; */&#10;@Serializable&#10;data class TTSJobStatusResponse(&#10;    val id: String,&#10;    val user_id: Int,&#10;    val module_id: Int? = null,&#10;    val status: String, // &quot;pending&quot;, &quot;processing&quot;, &quot;completed&quot;, &quot;failed&quot;&#10;    val audioUrl: String? = null,&#10;    val error: String? = null,&#10;    val created_at: String = &quot;&quot;,&#10;    val updated_at: String? = null&#10;)&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>